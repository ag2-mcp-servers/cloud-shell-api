# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T01:17:58+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field


class AddPublicKeyMetadata(BaseModel):
    pass


class AddPublicKeyRequest(BaseModel):
    key: Optional[str] = Field(
        None,
        description='Key that should be added to the environment. Supported formats are `ssh-dss` (see RFC4253), `ssh-rsa` (see RFC4253), `ecdsa-sha2-nistp256` (see RFC5656), `ecdsa-sha2-nistp384` (see RFC5656) and `ecdsa-sha2-nistp521` (see RFC5656). It should be structured as <format> <content>, where <content> part is encoded with Base64.',
    )


class AddPublicKeyResponse(BaseModel):
    key: Optional[str] = Field(
        None, description='Key that was added to the environment.'
    )


class AuthorizeEnvironmentMetadata(BaseModel):
    pass


class AuthorizeEnvironmentRequest(BaseModel):
    accessToken: Optional[str] = Field(
        None,
        description='The OAuth access token that should be sent to the environment.',
    )
    expireTime: Optional[str] = Field(
        None,
        description='The time when the credentials expire. If not set, defaults to one hour from when the server received the request.',
    )
    idToken: Optional[str] = Field(
        None, description='The OAuth ID token that should be sent to the environment.'
    )


class AuthorizeEnvironmentResponse(BaseModel):
    pass


class CancelOperationRequest(BaseModel):
    pass


class CreateEnvironmentMetadata(BaseModel):
    pass


class DeleteEnvironmentMetadata(BaseModel):
    pass


class Empty(BaseModel):
    pass


class State(Enum):
    STATE_UNSPECIFIED = 'STATE_UNSPECIFIED'
    SUSPENDED = 'SUSPENDED'
    PENDING = 'PENDING'
    RUNNING = 'RUNNING'
    DELETING = 'DELETING'


class Environment(BaseModel):
    dockerImage: Optional[str] = Field(
        None,
        description='Required. Immutable. Full path to the Docker image used to run this environment, e.g. "gcr.io/dev-con/cloud-devshell:latest".',
    )
    id: Optional[str] = Field(
        None,
        description="Output only. The environment's identifier, unique among the user's environments.",
    )
    name: Optional[str] = Field(
        None,
        description='Immutable. Full name of this resource, in the format `users/{owner_email}/environments/{environment_id}`. `{owner_email}` is the email address of the user to whom this environment belongs, and `{environment_id}` is the identifier of this environment. For example, `users/someone@example.com/environments/default`.',
    )
    publicKeys: Optional[List[str]] = Field(
        None,
        description='Output only. Public keys associated with the environment. Clients can connect to this environment via SSH only if they possess a private key corresponding to at least one of these public keys. Keys can be added to or removed from the environment using the AddPublicKey and RemovePublicKey methods.',
    )
    sshHost: Optional[str] = Field(
        None,
        description='Output only. Host to which clients can connect to initiate SSH sessions with the environment.',
    )
    sshPort: Optional[int] = Field(
        None,
        description='Output only. Port to which clients can connect to initiate SSH sessions with the environment.',
    )
    sshUsername: Optional[str] = Field(
        None,
        description='Output only. Username that clients should use when initiating SSH sessions with the environment.',
    )
    state: Optional[State] = Field(
        None, description='Output only. Current execution state of this environment.'
    )
    webHost: Optional[str] = Field(
        None,
        description='Output only. Host to which clients can connect to initiate HTTPS or WSS connections with the environment.',
    )


class RemovePublicKeyMetadata(BaseModel):
    pass


class RemovePublicKeyRequest(BaseModel):
    key: Optional[str] = Field(
        None, description='Key that should be removed from the environment.'
    )


class RemovePublicKeyResponse(BaseModel):
    pass


class State1(Enum):
    STATE_UNSPECIFIED = 'STATE_UNSPECIFIED'
    STARTING = 'STARTING'
    UNARCHIVING_DISK = 'UNARCHIVING_DISK'
    AWAITING_COMPUTE_RESOURCES = 'AWAITING_COMPUTE_RESOURCES'
    FINISHED = 'FINISHED'


class StartEnvironmentMetadata(BaseModel):
    state: Optional[State1] = Field(
        None, description='Current state of the environment being started.'
    )


class StartEnvironmentRequest(BaseModel):
    accessToken: Optional[str] = Field(
        None,
        description='The initial access token passed to the environment. If this is present and valid, the environment will be pre-authenticated with gcloud so that the user can run gcloud commands in Cloud Shell without having to log in. This code can be updated later by calling AuthorizeEnvironment.',
    )
    publicKeys: Optional[List[str]] = Field(
        None,
        description='Public keys that should be added to the environment before it is started.',
    )


class StartEnvironmentResponse(BaseModel):
    environment: Optional[Environment] = Field(
        None, description='Environment that was started.'
    )


class Status(BaseModel):
    code: Optional[int] = Field(
        None,
        description='The status code, which should be an enum value of google.rpc.Code.',
    )
    details: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='A list of messages that carry the error details. There is a common set of message types for APIs to use.',
    )
    message: Optional[str] = Field(
        None,
        description='A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.',
    )


class FieldXgafv(Enum):
    field_1 = '1'
    field_2 = '2'


class Alt(Enum):
    json = 'json'
    media = 'media'
    proto = 'proto'


class Operation(BaseModel):
    done: Optional[bool] = Field(
        None,
        description='If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.',
    )
    error: Optional[Status] = Field(
        None,
        description='The error result of the operation in case of failure or cancellation.',
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.',
    )
    name: Optional[str] = Field(
        None,
        description='The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.',
    )
    response: Optional[Dict[str, Any]] = Field(
        None,
        description='The normal response of the operation in case of success. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.',
    )


class ListOperationsResponse(BaseModel):
    nextPageToken: Optional[str] = Field(
        None, description='The standard List next-page token.'
    )
    operations: Optional[List[Operation]] = Field(
        None,
        description='A list of operations that matches the specified filter in the request.',
    )
